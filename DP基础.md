# 背包DP



## 0-1背包

>**问题：**有 n 个物品和一个容量为 W 的背包，每个物品有重量 wi 和价值 vi 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

````C++
for (int i = 1; i <= n; i++)
  	for (int l = 0; l <= W - w[i]; l++)
    	f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);
````

压缩代码：

```C++
for (int i = 1; i <= n; i++)
	for (int l = W; l >= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);
```



## 完全背包

> 完全背包模型与 0-1 背包类似，与 0-1 背包的区别仅在于一个物品可以选取无限次，而非仅能选取一次。

$$
f_{i,j}=\max_{k=0}^{+\infty}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

$$
f_{i,j}=\max(f_{i-1,j},f_{i,j-w_i}+v_i)
$$

```C++
for (int i = 1; i <= n; i++)
	for (int l = w[i]; l <= W; l++)
      	if (f[l - w[i]] + v[i] > f[l]) f[l] = f[l - w[i]] + v[i];
```



## 多重背包

>多重背包也是 0-1 背包的一个变式。与 0-1 背包的区别在于每种物品 y 有 ki个，而非 1 个。

$$
f_{i,j}=\max_{k=0}^{k_i}(f_{i-1,j-k\times w_i}+v_i\times k)
$$

### 二进制分组优化

通过「二进制分组」的方式使拆分方式更加优美。

```C++
index = 0;
for (int i = 1; i <= m; i++) {
  	int c = 1, p, h, k;
  	cin >> p >> h >> k;
  	while (k - c > 0) {
    	k -= c;
    	list[++index].w = c * p;
    	list[index].v = c * h;
    	c *= 2;
  	}
  	list[++index].w = p * k;
  	list[index].v = h * k;
}
```

### 单调队列优化

> 你有 n 个物品，每个物品重量为  wi ，价值为 vi ，数量为  vi 。你有一个承重上限为  m  的背包，现在要求你在不超过重量上限的情况下选取价值和尽可能大的物品放入背包。求最大价值。

设：
$$
g_{x,y}=f_{i,x\times w_i+y},g'_{x,y}=f_{i-1,x\times w_i+y}
$$
则转移方程可以表示为：
$$
g_{x,y}=\max_{k=0}^{k_i}(g'_{x-k,y}+v_i\times k)
$$


## 分组背包

所谓分组背包，就是将物品分组，每组的物品相互冲突，最多只能选一个物品放进去。

```C++
for (int k = 1; k <= ts; k++)          // 循环每一组
  	for (int i = m; i >= 0; i--)         // 循环背包容量
    	for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品
      		if (i >= w[t[k][j]])
        		dp[i] = max(dp[i],
                dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移
```

## 有依赖的背包

这种背包问题其实就是如果选第  i  件物品，就必须选第  j  件物品，保证不会循环引用，一部分题目甚至会出现多叉树的引用形式。为了方便，就称不依赖于别的物品的物品称为「主件」，依赖于某主件的物品称为「附件」。

对于包含一个主件和若干个附件的集合有以下可能性：仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……需要将以上可能性的容量和价值转换成一件件物品。因为这几种可能性只能选一种，所以可以将这看成分组背包。

如果是多叉树的集合，则要先算子节点的集合，最后算父节点的集合。



## 数位DP

>不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，在A和B之间，包括A和B，总共有多少个windy数？

```C++
#include<bits/stdc++.h>
#define ll long long
#define int long long
int a[20];
ll dp[20][10];//不同题目状态不同
ll dfs(int pos,int state/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)
    //不是每个题都要判断前导零
{
    //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了
    if(pos==-1) return 1;
    /*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，
    也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。
    不过具体题目不同或者写法不同的话不一定要返回1 */
    //第二个就是记忆化(在此前可能不同题目还能有一些剪枝)
    if(!limit && !lead && dp[pos][state]!=-1) return dp[pos][state];
    /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应 */
    int up=limit?a[pos]:9;//根据limit判断枚举的上界up
    ll ans=0;
    //开始计数
    for(int i=0;i<=up;i++)//枚举，然后把不同情况的个数加到ans就可以了
    {
        if(abs(i-state)<2) continue;
        if(lead&&!i)
            ans+=dfs(pos-1,-2/*状态转移*/,lead && i==0,limit && i==a[pos]);
        else
            ans+=dfs(pos-1,i/*状态转移*/,lead && i==0,limit && i==a[pos]); 
        //最后两个变量传参都是这样写的
        /*这里还算比较灵活，不过做几个题就觉得这里也是套路了
        大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论
        去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目
        要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类，
        前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/
    }
    //计算完，记录状态
    if(!limit && !lead) dp[pos][state]=ans;
    /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，
    这里就是lead就完全不用考虑了*/
    return ans;
}
ll solve(ll x)
{
    int pos=0;
    while(x)//把数位都分解出来
    {
        a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行
        x/=10;
    }
    return dfs(pos-1/*从最高位开始枚举*/,-2/*一系列状态 */,true,true);
    //刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛
}
signed main()
{
    ll l,r;
    while(~scanf("%lld%lld",&l,&r))
    {
        //初始化dp数组为-1
        memset(dp,-1,sizeof(dp));
        printf("%lld\n",solve(r)-solve(l-1));
    }
}
```





# 区间DP

区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来由很大的关系。令状态 f ( i, j ) 表示将下标位置 i 到 j 的所有元素合并获得的最大值，那么 f ( i, j ) = max{ f( i , k) + f( k + 1, j) + cost }，cost 为将这两组元素合并起来的代价。

**区间 DP 的特点：**

**合并** ：即将两个或多个部分进行整合，当然也可以反过来；

**特征** ：能将问题分解为能两两合并的形式；

**求解** ：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。

```C++
for (len = 1; len <= n; len++)
  	for (i = 1; i <= 2 * n - 1; i++) {
    	int j = len + i - 1;
    	for (k = i; k < j && k <= 2 * n - 1; k++)
      		f[i][j] = max(f[i][j], 
                          f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);
  	}
```
